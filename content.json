{"meta":{"title":"Goodboy Bobby","subtitle":"The world sucks, but I gonna love it","description":"The world sucks, but I gonna love it","author":"Lipeng Zhu","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"BinaryTree","slug":"BinaryTree","date":"2018-08-17T13:05:37.000Z","updated":"2018-08-18T00:23:27.082Z","comments":true,"path":"2018/08/17/BinaryTree/","link":"","permalink":"http://yoursite.com/2018/08/17/BinaryTree/","excerpt":"","text":"BinaryTree defination, initialization, traversals(preorder, inorder and postorder &amp;&amp; recursive and not). 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218public class Main &#123; public static class TreeNode&lt;T&gt;&#123; //defination T data; TreeNode&lt;T&gt; left=null; TreeNode&lt;T&gt; right=null; //constructors public TreeNode() &#123;&#125; public TreeNode(T data) this.data=data; public TreeNode(T data, TreeNode left, TreeNode right) &#123; this.data = data; this.left = left; this.right = right; &#125; &#125; public static class BinaryTree&lt;T&gt;&#123; private TreeNode&lt;T&gt; root; /*****constructors*****/ public BinaryTree()&#123;&#125; public BinaryTree(TreeNode&lt;T&gt; root) this.root = root; //initialization with a given array public BinaryTree(int element[], int size)&#123; TreeNode[] nodes = new TreeNode[size]; for (int i = 0; i &lt; size; i++)&#123; if(element[i] &lt; 0) nodes[i] = null; else nodes[i] = new TreeNode(element[i]); &#125; LinkedList&lt;TreeNode&gt; nodeQueue = new LinkedList&lt;&gt;(); TreeNode node; int index = 1; nodeQueue.add(nodes[0]); while(index &lt; size)&#123; node = nodeQueue.remove(); nodeQueue.add(nodes[index++]); node.left = nodeQueue.getLast(); nodeQueue.add(nodes[index++]); node.right = nodeQueue.getLast(); &#125; this.root = nodes[0]; &#125; /*****traversals*****/ //recursive preorder public void preOrder(TreeNode&lt;T&gt; root)&#123; if(root!=null)&#123; visit(root); preOrder(root.left); preOrder(root.right); &#125; &#125; //non-recursive preorder /* 1.visit node P and push P into stack. 2.judge whether P.left is null. If null, pop the stack and set P.right as current P and jump to 1.set P.left as current if not. 3.Traversal stops when P is null and stack is empty.*/ public void nonRecursivePreOrder(TreeNode&lt;T&gt; root)&#123; Stack&lt;TreeNode&lt;T&gt;&gt; s=new Stack&lt;TreeNode&lt;T&gt;&gt;(); if(root!=null)&#123; s.push(root); while(!s.isEmpty())&#123; TreeNode&lt;T&gt; node=s.pop(); visit(node); if(node.right!=null) s.push(node.right); if(node.left!=null) s.push(node.left); &#125; &#125; &#125; //recursive inorder public void inOrder(TreeNode&lt;T&gt; root)&#123; if(root!=null)&#123; inOrder(root.left); visit(root); inOrder(root.right); &#125; &#125; //non-recursive inorder /* 1.Push the current node to S and set current = current-&gt;left until current is NULL 2.If current is NULL and stack is not empty then a) Pop the top item from stack. b) Print the popped item, set current = popped_item-&gt;right c) Go to step 1. 3.If current is NULL and stack is empty we are done.*/ public void nonRecursiveInOrder(TreeNode&lt;T&gt; root)&#123; Stack&lt;TreeNode&lt;T&gt;&gt; stack=new Stack&lt;TreeNode&lt;T&gt;&gt;(); TreeNode&lt;T&gt; node=root; while(node!=null||!stack.isEmpty())&#123; //keep pushing right child into stack //until finding the node with null left child while(node!=null)&#123; stack.push(node); node=node.left; &#125; node=stack.pop(); visit(node); node=node.right;// &#125; &#125; //recursive postorder public void postOrder(TreeNode&lt;T&gt; root)&#123; if(root!=null)&#123; postOrder(root.left); postOrder(root.right); visit(root); &#125; &#125; //non-recursive postorder public void nonRecursivePostOrder(TreeNode&lt;T&gt; root)&#123; TreeNode&lt;T&gt; node=root; TreeNode&lt;T&gt; preNode=null; //record of right nodes that have been traversd Stack&lt;TreeNode&lt;T&gt;&gt; stack=new Stack&lt;TreeNode&lt;T&gt;&gt;(); while(node!=null||!stack.isEmpty())&#123; while(node!=null)&#123; stack.push(node); node=node.left; &#125; node=stack.peek();//read but not pop if(node.right==null||node.right==preNode)&#123; visit(node); node=stack.pop(); preNode = node; node=null; &#125; else node=node.right; &#125; &#125; //level traversal public void levelTraverse(TreeNode&lt;T&gt; root)&#123; //Queue is an interface and cannot be instanced //usually we use LinkedList as queue. Queue&lt;TreeNode&lt;T&gt;&gt; queue=new LinkedList&lt;TreeNode&lt;T&gt;&gt;(); TreeNode&lt;T&gt; node=root; queue.offer(node);//push element into queue while(!queue.isEmpty())&#123; node=queue.poll();//pop out node if(node!=null)&#123; visit(node); //push node.left and node.right to queue queue.offer(node.left); queue.offer(node.right); &#125; &#125; &#125; //recursive leaf nodes traversal public void RecursiveLeafNodeTraversal(TreeNode&lt;T&gt; root, ArrayList&lt;T&gt; l)&#123; if(root == null) return; if(root.left == null &amp;&amp; root.right == null) l.add(root.val); if(root.left != null) leafNodeTraversal(root.left); if(root.right != null) leafNodeTraversal(root.right); &#125; //non-recursive leaf nodes traversal public void NonRecursiveLeafNodeTraversal(TreeNode&lt;T&gt; root, ArrayList&lt;T&gt; l)&#123; Stack&lt;TreeNode&lt;T&gt;&gt; s = new Stack&lt;&gt;() s.push(root); while(!s.empty())&#123; TreeNode node = s.pop(); if(node.right != null) s.push(node.right); if(node.left != null) s.push(node.left); if(node.right == null &amp;&amp; node.left == null) l.add(node.val); &#125; &#125; &#125;&#125;","categories":[],"tags":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://yoursite.com/tags/Data-Structure/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Common Ways to Optimize Program","slug":"Common Ways to Optimize Program","date":"2018-08-12T11:40:52.000Z","updated":"2018-08-12T14:04:34.897Z","comments":true,"path":"2018/08/12/Common Ways to Optimize Program/","link":"","permalink":"http://yoursite.com/2018/08/12/Common Ways to Optimize Program/","excerpt":"","text":"Here I want to introduce some commonly used ways to make our programs faster. 1.Reduce frequency with which computation performed. Especially moving code out of loop if it will always peoduce the same result:12345678910111213141516//bad codevoid set_row(double *a, double *b, long i, long n)&#123; long j; for(j=0;j&lt;n;j++) a[n*i+j]=b[j];&#125;//good codevoid set_row(double *a, double *b, long i, long n)&#123; long j; int ni=n*i; for(j=0;j&lt;n;j++) a[ni+j]=b[j];&#125; Sometimes we can reuse portions of expressions to reduce computation by sharing common subexpressions: 123456789101112//bad codea = val[(i-1)*n + j];b = val[(i+1)*n + j];c = val[i*n + j-1];d = val[i*n + j+1];//good codelong inj = i*n + j;a = val[inj - n];b = val[inj + n];c = val[inj - 1];d = val[inj + 1]; 2.Replace costly operation with simpler one. Try to use shift and add instead of multiply or divide:12345//bad codey = x * 16;//good codey = x &lt;&lt; 4; 3.Pay attention to procedure calls in loop:12345678910111213141516171819//bad codevoid lower(char *s)&#123; size_t i; for (i=0;i&lt;strlen(s);i++) if (s[i] &gt;= 'A' &amp;&amp; s[i] &lt;= 'Z') s[i] -= ('A' - 'Z');&#125;//good codevoid lower(char *s)&#123; size_t i; size_t len = strlen(s); for (i=0;i&lt;len;i++) if (s[i] &gt;= 'A' &amp;&amp; s[i] &lt;= 'Z') s[i] -= ('A' - 'Z');&#125; 4.Memory matters. Try not to update memory in every loop, use local variable instead because it is stored in register which is easier to load than those stored in memory.123456789101112131415161718192021222324//bad codevoid sum_rows1(double *a, double *b, long n)&#123; long i,j; for (i=0;i&lt;n;i++) &#123; b[i]=0; for (j=0;j&lt;n;j++) b[i] += a[i*n + j]; &#125;&#125;//good codevoid sum_rows2(double *a, double *b, long n)&#123; long i,j; for (i=0;i&lt;n;i++) &#123; double val = 0; for (j=0;j&lt;n;j++) val += a[i*n + j]; b[i] = val; &#125;&#125; Difference can be shown from the assembly code below:","categories":[],"tags":[{"name":"Programming","slug":"Programming","permalink":"http://yoursite.com/tags/Programming/"}]},{"title":"Bit manipulations","slug":"Bit manipulations","date":"2018-06-17T19:48:52.000Z","updated":"2018-06-17T13:40:28.289Z","comments":true,"path":"2018/06/17/Bit manipulations/","link":"","permalink":"http://yoursite.com/2018/06/17/Bit manipulations/","excerpt":"","text":"Before saying anything else, let’s declare the legal stuff: I collected all these little helpful pieces of code on the internet. All links are listed in the Reference. In this passage, I want to collect some commonly used bit manupulations. 1. Bit manipulation basics123456789101112131415161718192021222324252627282930int setBit(int x, unsigned char position)&#123; int mask = 1 &lt;&lt; position; return x | mask;&#125;int clearBit(int x, unsigned char position)&#123; int mask = 1 &lt;&lt; position; return x &amp; ~mask;&#125;int modifyBit(int x, unsigned char position, bool newState)&#123; int mask = 1 &lt;&lt; position; int state = int(newState); // relies on true = 1 and false = 0 return (x &amp; ~mask) | (-state &amp; mask);&#125;int flipBit(int x, unsigned char position)&#123; int mask = 1 &lt;&lt; position; return x ^ mask;&#125;bool isBitSet(int x, unsigned char position)&#123; x &gt;&gt;= position; return (x &amp; 1) != 0;&#125; Here are the basics of boolean algebra: 0 OR 0 → 00 OR 1 → 11 OR 0 → 11 OR 1 → 1 0 AND 0 → 00 AND 1 → 01 AND 0 → 01 AND 1 → 1 0 XOR 0 → 00 XOR 1 → 11 XOR 0 → 11 XOR 1 → 0 Whenever a bit needs to be set independent of its former state (setBit), OR comes in handy: input OR 1 → 1input OR 0 → input That means, a mask which is 1 for all bits to be set and 0 for all other bits fulfills our purposes (line 3, line 4). For clearing a bit (clearBit), AND has to be chosen because: input AND 0 → 0input AND 1 → input This time, the mask must be 0 for all cleared bits and 1 for bits keeping their former state.Line 10 uses the bit-wise negation to flip all bits of the mask accordingly. Flipping a bit (flipBit) is the domain of XOR: input XOR 1 → opposite of inputinput XOR 0 → input That code looks almost identical to OR. Last but not least, querying a single bit (isBitSet) can be implemented very similiar to clearing a single bit: create a mask, negate it, check for 0. To understand the manipulation of modifying a bit (modifyBit), we need to understand the principle of Machine code (true code, complement and ones-complement code). There is a good passage about it: 深入理解机器码（原码，反码，补码）和算术溢出 2.Absolute value of an integer12345int myAbs(int x)&#123; const int bit31 = x &gt;&gt; 31; return (x ^ bit31) - bit31;&#125; All major processors represent negative numbers using the two’s-complement which is defined as: for x ≥ 0 → xfor x &lt; 0 → NOT(x) + 1 On the lowest level, computers provide logical bit shifts and arithmetic bit shifts. Both shifts differ in handling how to fill the empty bits on the left side. Logical shifts insert zeros while arithmetic shifts replicate the formerly highest bit. Whereas signed integers are arithmetically shifted in C, unsigned integers are logically shifted. In our case x is shifted arithmetically 31 times to the right which basically erases its value and spreads the highest bit. That means, line 3 evaluates either to 0x00000000 (→ 0) or 0xFFFFFFFF (→ −1).Note: 32 bit systems require a shift by 31, 64 bit systems require a shift by 63 accordingly. Consequently, line 4 turns out to be (x XOR 0) − 0 for positive values of x (including x=0). x XOR 0 is still x and x − 0 remains x, too. So for positive x we get x ≥ 0 → x. We saw that for negative values of x, bit31 is set to 0xFFFFFFFF. Line 4 is then (x XOR 0xFFFFFFFF) − 0xFFFFFFFF. The bracketed XOR is equivalent to NOT(x) and the constant −0xFFFFFFFF turns out to be −(-1) = +1. In the end, the whole term is NOT(x) + 1, exactly what we wanted: for x &lt; 0 → NOT(x) + 1 3.Is power of two1234bool isPowerOfTwo(unsigned int x)&#123; return ((x &amp; (x-1)) == 0);&#125; It uses the fact that powers of two have one and only one bit set in their binary representation: x == 0…010…0x-1 == 0…001…1x &amp; (x-1) == 0…000…0 If the number is neither zero nor a power of two, it will have ‘1’ in more than one place: x == 0…1…010…0x-1 == 0…1…001…1x &amp; (x-1) == 0…1…000…0 4.Integers Comparison1234567int comparison(int x, int y)&#123; int diff = y-x; int bit31 = diff&gt;&gt;31; return (bit31 &amp; (x ^ y)) ^ y&#125; A universal helper operation sets bit31 (line 5) to either 0x00000000 or 0xFFFFFFFF. Then a special property of XOR is used: a XOR b XOR b = a, which means applying XOR twice with the same number eliminates this number. If bit31 is 0x00000000 (y &gt; x), line 6 becomes (0x00000000 AND (x XOR y)) XOR y, and since (zero AND something) = zero, only zero XOR y is left which returns y. if bit31 is 0xFFFFFFFF (y &lt; x), line 6 becomes (0xFFFFFFFF AND (x XOR y)) XOR y, and since (allBitsSet AND something) = something, (x XOR y) XOR y is left, which returns x as explained earlier. 5.Swap two values123456void swapXor(int&amp; a, int&amp; b)&#123; a ^= b; b ^= a; a ^= b;&#125; Line 3, line 4 and line 5 produce the following equations: line 3: anew = a XOR bline 4: bswapped = b XOR anew = b XOR (a XOR b) = aline 5: aswapped = anew XOR bswapped = (a XOR b) XOR a = b In the end, aswapped = b and bswapped = a. However, there are two restrictions: integers only and it must not be used with same variable twice, e.g., swapXor(a,a) 6.Sum two values1234567int getSum(int a, int b)&#123; if (a==0) return b; if (b==0) return a; return getSum(a^b, (a&amp;b)&lt;&lt;1);&#125; Let’s consider a simple sum operation: 5+17=22. We can compute in three steps in the decimal addition: 1 Ignore carry, only sum up the corresponding digits, get 12(5+7=12, ignore carry); 2 Record the carry, in the previous step calculation, there is only 1 carry and the carry value is 10; 3 Add the carry value to the first step result according to the method in step 1 to get the final result 22. The computation stops because there is no carry in this step(carry=0). Consider the case of binary numbers below (5=101, 17=10001): 1 Ignore carry, add the corresponding digits, get 10100; 2 Record the carry. In this example, only the last bit is added and the carry 1 is generated. The carry value is 10 (binary); 3 Add the carry value to the result of step 1 in the same way as in step 1 to get the final result 10110, which is exactly the binary representation of the decimal number 22. Next, replace the above-mentioned binary addition 3-step calculation method with bit manupulations: 1 Ignore Carry, 0+0=0, 0+1=1, 1+0=0, 1+1=0, typical XOR operation: a^b; 2 Obviously, only 1+1 will result in a carry value of 10 relative to this digit, and 10=(1&amp;1)&lt;&lt;1, which means (a&amp;b)&lt;&lt;1; 3 Add the results from Step 1 and 2 and repeat these two steps until no further carry. Reference[1]the bit twiddler[2]Bit manipulation","categories":[],"tags":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://yoursite.com/tags/Algorithms/"},{"name":"C","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"Commonly used operations of Dict","slug":"Commonly used operations of Dict","date":"2018-06-03T03:05:07.000Z","updated":"2018-06-02T15:16:48.486Z","comments":true,"path":"2018/06/02/Commonly used operations of Dict/","link":"","permalink":"http://yoursite.com/2018/06/02/Commonly used operations of Dict/","excerpt":"","text":"Here I want to list some commonly used operations of dictionary in Python. Reversing [Key Value]It is not easy to reverse &lt;key, value&gt; when there are duplicated values: 1234&gt;&gt;&gt; c1 = &#123;'a':1,'b':2,'c':1&#125;&gt;&gt;&gt; c2 = dict([(v,k) for k,v in c1.items()])&gt;&gt;&gt; c2&#123;1: 'c', 2: 'b'&#125; The right way to hold all keys in new value list is as below:Sort Characters By Frequency-solution-using-Hash-Map.) 123456&gt;&gt;&gt; c2 = &#123;&#125;&gt;&gt;&gt; for k,v in c1.items(): c2.setdefault(v,[]).append(k)&gt;&gt;&gt; c2&#123;1: ['a', 'c'], 2: ['b']&#125;","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"Applications of Fast and Slow Pointers","slug":"Applications of Fast and Slow Pointers","date":"2018-05-28T05:08:12.000Z","updated":"2018-05-27T17:52:24.386Z","comments":true,"path":"2018/05/28/Applications of Fast and Slow Pointers/","link":"","permalink":"http://yoursite.com/2018/05/28/Applications of Fast and Slow Pointers/","excerpt":"","text":"There are many applications of fast and slow pointers where ‘fast’ and ‘slow’ describe the step length of the pointers move. Applications in Linked List1.Judging a circular Linked ListIf there is a circle in the list, it looks like a circle playground. Let the fast and slow pointers traverse from the head of the list, the fast pointer moves two nodes forward each time while the slow pointer moves one. If the fast pointer reaches NULL, the linked list ends with NULL, and there is no cirle. If the fast pointer catches up with the slow pointer, it is a circular linked list. Linked List Cycle12345678910111213141516def hasCycle(self, head): \"\"\" :type head: ListNode :rtype: bool \"\"\" try: slow = head fast = head.next while slow is not fast: slow = slow.next fast = fast.next.next return True except: return False 2.Finding the median in an ordered Linked ListThe fast pointer moves twice as fast as the slow pointer, so when the fast pointer reaches the end of the list, the slow pointer reaches the midpoint. We should also consider the odd and even number of linked list nodes. When the fast pointer moves to the end of the table after x setp, it indicates that the linked list has an odd number of nodes, and the node pointed by the slow pointer can be directly returned as the median. If the fast pointer is the penultimate node, indicating that the number of linked list nodes is even, we can return to the upper or lower median according to the given rules. 1234567891011121314def findMedian(self, head): \"\"\" :type head: ListNode :rtype: ListNode \"\"\" slow = head fast = head while fast and fast.next: slow = slow.next fast = fast.next.next return slow 3.Finding the last K nodeThe concept of ‘fast’ and ‘slow’ can not only represent the speed of the movement, but also can be used to show the order of movement. We can define two pointers: The fast pointer walks forward by k-1 steps firstly while the slow pointer keeps still. From the Kth step, the second pointer also starts from the head of the linked list. Since the distance between two pointers keeps k-1, when the fast pointer reaches the end node of the list, the second pointer points Kth node from the bottom of the list. 123456789101112131415161718def getLastKthNode(self, k, head): \"\"\" :type head: ListNode :type k: int :rtype: ListNode \"\"\" slow = head fast = head for i in range(k): fast = fast.next while fast: fast = fast.next slow = slow.next return slow 4. Finding the entry node to the circular Linked ListApplications in ArrayGiven an array nums, write a function to move all 0s to the end of it while maintaining the relative order of the non-zero elements. We can use the slow pointer to indicate the first 0 waiting for swap while the fast pointer to indicate the current element Move Zeroes12345678910def moveZeroes(self, nums): \"\"\" :type nums: List[int] :rtype: void Do not return anything, modify nums in-place instead. \"\"\" zero = 0 for i in range(len(nums)): if not nums[i] == 0 and zero &lt;= i: nums[i], nums[zero] = nums[zero], nums[i] zero += 1","categories":[],"tags":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://yoursite.com/tags/Algorithms/"}]},{"title":"Little tricks of Array in Python","slug":"Little tricks of Array in Python","date":"2018-05-20T23:25:23.000Z","updated":"2018-05-20T12:42:27.330Z","comments":true,"path":"2018/05/20/Little tricks of Array in Python/","link":"","permalink":"http://yoursite.com/2018/05/20/Little tricks of Array in Python/","excerpt":"","text":"Important hints Could you do it without extra space and in O(n) runtime? “No extra space” means that we should modify the array itself to record some information and O(n) runtime usually means that we should have only one loop. For example, we can use the positive and negative values of elements in the array to record their occurences: Given an array of integers, 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once. Find all the elements that appear twice in this array. 123456789101112def findDuplicates(self, nums): \"\"\" :type nums: List[int] :rtype: List[int] \"\"\" res = [] for x in nums: if nums[abs(x)-1] &lt; 0: res.append(abs(x)) else: nums[abs(x)-1] *= -1 return res In the same way, if we need a solution with O(log n), we need to figure out binary tree or recursion: Given a sorted array consisting of only integers where every element appears twice except for one element which appears once. Find this single element that appears only once. 1234567891011121314151617181920212223242526272829def singleNonDuplicate(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" def recursion(nums): if len(nums) == 3: if nums[0] == nums[1]: return nums[2] else: return nums[0] flag = math.ceil(len(nums)/2) a = nums[:flag] b = nums[flag:] if flag%2 : if a[-1] == b[0]: return recursion([a[-1]] + b) else: return recursion(a) else: if a[-1] == b[0]: return recursion(a[:-1]) else: return recursion(b) return recursion(nums) Given an array of integers, 1 ≤ a[i] ≤ n (n = size of array). “1 ≤ a[i] ≤ n” guides us to use value of a[i] as the index of elements like a[a[i]] just like the first example above.","categories":[],"tags":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://yoursite.com/tags/Data-Structure/"},{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"Leetcode Wrong Answers","slug":"Leetcode Wrong Answers","date":"2018-05-17T01:56:07.000Z","updated":"2018-05-16T14:00:44.623Z","comments":true,"path":"2018/05/16/Leetcode Wrong Answers/","link":"","permalink":"http://yoursite.com/2018/05/16/Leetcode Wrong Answers/","excerpt":"","text":"Linked List328. Odd Even Linked List 83. Remove Duplicates from Sorted List 445. Add Two Numbers II","categories":[],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://yoursite.com/tags/Leetcode/"}]},{"title":"Commonly used operations of Linked List","slug":"Commonly used operations of Linked List","date":"2018-05-13T02:09:08.000Z","updated":"2018-06-21T03:02:14.206Z","comments":true,"path":"2018/05/12/Commonly used operations of Linked List/","link":"","permalink":"http://yoursite.com/2018/05/12/Commonly used operations of Linked List/","excerpt":"","text":"Here I want to list some commonly used operations of linked list. 1.Reversing Linked ListThere are two typical ways to reverse the linkedlist: iteratively or recursively. 1234class ListNode(object): def __init__(self, x): self.val = x self.next = None 12345678910111213141516#Iterativelydef reverseList(self, head): \"\"\" :type head: ListNode :rtype: ListNode \"\"\" prevnode = None p = head while p: nextnode = p.next p.next = prevnode prevnode = p p = nextnode return prevnode 123456789101112#Recursivelydef reverseList(self, head, prev = None): \"\"\" :type head: ListNode :rtype: ListNode \"\"\" if not head: return prev curr = head.next head.next = prev return self.reverseList(curr, head) It can also achieve the same effect using stack. 12345678910111213141516171819202122class StackUnderflow(ValueError): passclass SStack(): def __init__(self): self._elems = [] def is_empty(self): return self._elems == [] def top(self): if self._elems == []: raise StackUnderflow(\"in SStack.top()\") return self._elems[-1] def push(self, elem): self._elems.append(elem) def pop(self): if self._elems == []: raise StackUnderflow(\"in SStack.pop()\") return self._elems.pop() 12345678910111213141516171819202122#Stackdef reverseList(self, head): \"\"\" :type head: ListNode :rtype: ListNode \"\"\" s = SStack() n = 0 while head: s.push(head.val) head = head.next n += 1 rev = ListNode(s.pop()) p =rev for i in range(n-1): p.next = ListNode(s.pop()) p = p.next return rev 2.Locating the Midpoint of Linked ListThe fast pointer moves twice as fast as the slow pointer, so when the fast pointer reaches the end of the list, the slow pointer reaches the midpoint. 12345678910def findMedian(self, head): slow = head fast = head while fast and fast.next: slow = slow.next fast = fast.next.next return slow 3.Sorting Linked List &amp; Deleting and Inserting NodesInsertion Sort: Use p to indicate the insertion position, cur.next to indicate the target node, and cur to indicate the biggest node (also the last node) in the sorted linked list partition before the target node. When deleting and inserting nodes we need to know the nodes before the one to be removed and the one before the position to insert 1234567891011121314151617def insertionSortList(self, head): p = dummy = ListNode(0) cur = dummy.next = head while cur and cur.next: val = cur.next.val if cur.val&lt;val: #a quick check see if the new value is already the largest cur = cur.next #not necessary but key to improve effeciency continue if p.next.val&gt;val: p = dummy while p.next.val &lt;val: #find the position to insert p = p.next temp = cur.next #delete 'cur.next' and insert into list after 'p' cur.next = temp.next #we need a extra node 'temp' to record temp.next = p.next p.next = temp return dummy.next 4.Merging two Linked ListsWe must follow certain rules when merging two lists and we assume here to merge two sorted lists in ascending order 12345678910111213# iterativelydef mergeTwoLists1(self, l1, l2): dummy = cur = ListNode(0) while l1 and l2: if l1.val &lt; l2.val: cur.next = l1 l1 = l1.next else: cur.next = l2 l2 = l2.next cur = cur.next cur.next = l1 or l2 #Tends to be faster using if judgement return dummy.next 12345678910# recursively def mergeTwoLists2(self, l1, l2): if not l1 or not l2: return l1 or l2 if l1.val &lt; l2.val: l1.next = self.mergeTwoLists(l1.next, l2) return l1 else: l2.next = self.mergeTwoLists(l1, l2.next) return l2 5. Inserting Node before given NodeIt is hard to find a previous node in a single linked list, but it is easy to insert a node after a given node. We can insert the new node after the given node and then exchange the data for the given node and the new node.","categories":[],"tags":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://yoursite.com/tags/Data-Structure/"}]},{"title":"Attentions when using Linked List","slug":"Attentions when using Linked List","date":"2018-05-12T17:02:46.000Z","updated":"2018-05-15T03:55:47.954Z","comments":true,"path":"2018/05/12/Attentions when using Linked List/","link":"","permalink":"http://yoursite.com/2018/05/12/Attentions when using Linked List/","excerpt":"","text":"Here I want to list the mistakes I made when using linked list Empty linked listSometimes an empty list is given to check if the program takes into account the special circumstances of the input. Take care especially when we use ‘head.next’ at the very beginning. We can use the following code to filter those naughty input: 12if head is None or head.next is None: return head 15/15/2018 Wrong Again! Process of boundary nodes12345678910prevnode = headp = head.nextwhile p: nextnode = p.next p.next = prevnode prevnode = p p = nextnodenewll = prevnode a short and seemed effect code to reverse a given linked list strated with head, but when we want to count the length of ‘newll’ the program will never stop. Why? Because we forget to process the first node of the original linkedlist: head. head.next still exist and it points to second node in the original linkedlist so this is a infinite linked list where nodes switch back and forth between the first and second nodes. There is another kind of error-prone case: Sometime the head node may be removed from the linked list, using ‘head’ node to index a linked list in this case is error prone. Example Linked list breakWhenever we want to change node.next, remember to record the ‘name’ of next node by assinging another variable, otherwise the linked list will break.","categories":[],"tags":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://yoursite.com/tags/Data-Structure/"}]},{"title":"Iterator and list resolution in Python (Part A)","slug":"Iterator and list resolution in Python (Part A)","date":"2018-05-08T02:37:31.000Z","updated":"2018-05-12T05:07:15.083Z","comments":true,"path":"2018/05/07/Iterator and list resolution in Python (Part A)/","link":"","permalink":"http://yoursite.com/2018/05/07/Iterator and list resolution in Python (Part A)/","excerpt":"","text":"Introduction to IteratorTo understand how iterator works in Python, let’s take some for loops for example: 123456789&gt;&gt;&gt; for x in [1,2,3,4]: print(x, end = ' ')1 2 3 4 &gt;&gt;&gt; for x in (1,2,3,4): print(x, end = ' ')1 2 3 4 &gt;&gt;&gt; for x in 'spam': print(x, end = ' ')s p a m In fact, the source ([1,2,3,4], (1,2,3,4) and ‘spam’ there) of the loop variable(x) in for loop can be more general than these three types, it can be any Iterable objects. The concept of “Iterable objects” is kind of novel in Python but very common in programming. There is a generalized definition: Any object that is actually saved as a list or that can produce one result at a time in an iterative tool environment is an iterable object. In the example above three sources are all iterable objects because they can provide a result in every loop. The iterative tools we mentioned in the definition is corresponsive to iterable objects which scan objects from left to right. These iterative tools include for loops, list comprehensions, in membership tests, and map built-in functions One famous application of iterable object is file operation. We know that there is a method named readline() for file object which will return one line of text in the file opened once called: 1234567&gt;&gt;&gt; f = open('helloworld.py')&gt;&gt;&gt; f.readline()'import sys\\n'&gt;&gt;&gt; f.readline()\"print('hello world!')\"&gt;&gt;&gt; f.readline()'' Now we can use another method of file object named next which can achieve the same result: it will return next line of text once called. 12345678910&gt;&gt;&gt; f = open('helloworld.py')&gt;&gt;&gt; f.__next__()'import sys\\n'&gt;&gt;&gt; f.__next__()\"print('hello world!')\"&gt;&gt;&gt; f.__next__()Traceback (most recent call last): File \"&lt;pyshell#32&gt;\", line 1, in &lt;module&gt; f.__next__()StopIteration There are two features worth attention. First is that every time next() method called, the next result of the object will be returned, so we can judge whether an object is an iterator by checking it. Second is a difference between file.next() and file.readline() that when it reaches the end of a series of results, it will trigger an exception named StopIteration. We can catch this exception to determine when to leave when using iterative tools we mentioned above. When we know that there is a method named next() in file object, we can make sure that file object is a iterable object so we can use iterative tools to simplify our codes: 1234&gt;&gt;&gt; for line in open('helloworld.py'): print(line, end='')import sysprint('hello world!') In fact, all iterative tools will call the next()method of the iterable objects every loop to get the next result in the object. At this point we may have the following questions: The list is the first iterable object we know and be most familiar with, what happens when we try to call list.next()? 123456&gt;&gt;&gt; a=[1,2,3,4]&gt;&gt;&gt; a.__next__()Traceback (most recent call last): File \"&lt;pyshell#47&gt;\", line 1, in &lt;module&gt; a.__next__()AttributeError: 'list' object has no attribute '__next__' Oops! What’s wrong with list? To understand this error, we need to be clear about two terms: iterable object and iterator. The biggest difference between them is that iterator has next() method but an iterable object does not. To make it direct, a list is an iterable object but not an iterator so it does not have a next() method, while a file is both an iterable object and an iterator. In fact, we can use a built-in function called iter() to change an iterable object into a iterator. We can use this example to show the difference between list and file: 123456789101112131415&gt;&gt;&gt; a=[1,2,3,4]&gt;&gt;&gt; b=iter(a)&gt;&gt;&gt; b.__next__()1&gt;&gt;&gt; b.__next__()2&gt;&gt;&gt; b.__next__()3&gt;&gt;&gt; b.__next__()4&gt;&gt;&gt; b.__next__()Traceback (most recent call last): File \"&lt;pyshell#55&gt;\", line 1, in &lt;module&gt; b.__next__()StopIteration 1234567891011&gt;&gt;&gt; f=open('helloworld.py')&gt;&gt;&gt; c=iter(f)&gt;&gt;&gt; c.__next__()'import sys\\n'&gt;&gt;&gt; c.__next__()\"print('hello world!')\"&gt;&gt;&gt; c.__next__()Traceback (most recent call last): File \"&lt;pyshell#60&gt;\", line 1, in &lt;module&gt; c.__next__()StopIteration 1234567891011&gt;&gt;&gt; f=open('helloworld.py')&gt;&gt;&gt; f.__next__()'import sys\\n'&gt;&gt;&gt; f.__next__()\"print('hello world!')\"&gt;&gt;&gt; c=iter(f)&gt;&gt;&gt; c.__next__()#Attention here! next(c) returns the same result of next(f) Traceback (most recent call last): File \"&lt;pyshell#65&gt;\", line 1, in &lt;module&gt; c.__next__()StopIteration By now, we have a preliminary understanding of iterators. It is a good tool in programming if applied properly. In most common cases, we can use iterator together with for loop to take place of while loop to run faster. Because iterators run in Python at the speed of C language, while the while loop runs python bytecode through the python virtual machine. At any time, it should be faster if we replace the python code with the C code. There are two often used iterable object: dictionary and range() 1234567891011&gt;&gt;&gt; Dict = &#123;'a':1,'b':2,'c':3&#125;&gt;&gt;&gt; for i in Dict: print(i, Dict[i])a 1b 2c 3&gt;&gt;&gt; for i in range(2):print(i)01 Attention that we need to wrap an iterable object into a list call to see all the values at once 1234&gt;&gt;&gt; range(2)range(0, 2)&gt;&gt;&gt; list(range(2))[0, 1] Introduction to list resolutionList resolution derives from the concept of collections. It is a way to create a new list by running an expression on each item in the sequence, one at a time, from left to right. List resolutions are composed of square brackets (reminding us the fact that we are creating a list) and operational expressions and loop structures that use the same variable name. Let’s look at an example: 1234&gt;&gt;&gt; L = [1,2,3,4]&gt;&gt;&gt; L1 = [x+10 for x in L]&gt;&gt;&gt; L1[11, 12, 13, 14] In this example, the operational expression(x+10) and loop structure(for x in L) use the same variable(x). During execution, the python interpreter internally performs a list traversal, assigns each x in order to an element and collects the results of running the left expression for each element. The list of results we get is a list containing a new list of x+10 for each x from L. When we use list resolution together with iterators, it greatly simplifies our code. At any time we want to perform same operations on each element in a sequence, we can consider the usage of list resolution: 123&gt;&gt;&gt; lines = [line.rstrip() for line in open('helloworld.py')]&gt;&gt;&gt; lines['import sys', \"print('hello world!')\"] If we want to skip some element in a consequence, we can use an if judgement to filter the list resolution: 12&gt;&gt;&gt; [x for x in range(5) if x%2 ==0][0, 2, 4] When the for expression in resolution is nested, it equals to nested for loop when run: 12&gt;&gt;&gt; [x + y for x in [0,1,2] for y in [10,20,30]][10, 20, 30, 11, 21, 31, 12, 22, 32] Equals to: (Pay attention to the outer loop variable(x) and inner loop variable(y)) 123456&gt;&gt;&gt; res = []&gt;&gt;&gt; for x in [0,1,2]: for y in [10,20,30]: res.append(x+y)&gt;&gt;&gt; res[10, 20, 30, 11, 21, 31, 12, 22, 32] A typical usage is given below: 12&gt;&gt;&gt; [(x,y) for x in range(5) if x%2==0 for y in range(5) if y%2 ==1][(0, 1), (0, 3), (2, 1), (2, 3), (4, 1), (4, 3)] It is worth mentioning that list resolution allows us to perform matrix operations in Python more easily. A basic method to operate matrix is to use nested list: 1234567891011121314&gt;&gt;&gt; M = [[1,2,3], [4,5,6], [7,8,9]]&gt;&gt;&gt; N = [[2,2,2], [3,3,3], [4,4,4]]&gt;&gt;&gt; [row[1] for row in M][2, 5, 8]&gt;&gt;&gt; [M[i][i] for i in range(len(M))][1, 5, 9]&gt;&gt;&gt; [M[row][col] * N[row][col] for row in range(3) for col in range(3)][2, 4, 6, 12, 15, 18, 28, 32, 36]&gt;&gt;&gt; [[M[row][col] * N[row][col] for row in range(3) ]for col in range(3)][[2, 12, 28], [4, 15, 32], [6, 18, 36]] Attention to the difference here resulted from consequence of inner and outer loop","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-05-06T07:06:54.592Z","updated":"2018-05-06T07:06:54.593Z","comments":true,"path":"2018/05/06/hello-world/","link":"","permalink":"http://yoursite.com/2018/05/06/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}