{"meta":{"title":"The Street Where Wind Settles","subtitle":"The world sucks, but I gonna love it","description":"The world sucks, but I gonna love it","author":"Lipeng Zhu","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"Commonly used operations of Linked List","slug":"Commonly used operations of Linked List","date":"2018-05-12T14:09:08.000Z","updated":"2018-05-12T15:48:31.667Z","comments":true,"path":"2018/05/12/Commonly used operations of Linked List/","link":"","permalink":"http://yoursite.com/2018/05/12/Commonly used operations of Linked List/","excerpt":"","text":"Here I want to list some commonly used operations of linked list. Reversing Linked ListThere are two typical ways to reverse the linkedlist: iteratively or recursively. 1234class ListNode(object): def __init__(self, x): self.val = x self.next = None 12345678910111213141516#Iterativelydef reverseList(self, head): \"\"\" :type head: ListNode :rtype: ListNode \"\"\" prevnode = None p = head while p: nextnode = p.next p.next = prevnode prevnode = p p = nextnode return prevnode 123456789101112#Recursivelydef reverseList(self, head, prev = None): \"\"\" :type head: ListNode :rtype: ListNode \"\"\" if not head: return prev curr = head.next head.next = prev return self.reverseList(curr, head) It can also achieve the same effect using stack. 12345678910111213141516171819202122class StackUnderflow(ValueError): passclass SStack(): def __init__(self): self._elems = [] def is_empty(self): return self._elems == [] def top(self): if self._elems == []: raise StackUnderflow(\"in SStack.top()\") return self._elems[-1] def push(self, elem): self._elems.append(elem) def pop(self): if self._elems == []: raise StackUnderflow(\"in SStack.pop()\") return self._elems.pop() 12345678910111213141516171819202122#Stackdef reverseList(self, head): \"\"\" :type head: ListNode :rtype: ListNode \"\"\" s = SStack() n = 0 while head: s.push(head.val) head = head.next n += 1 rev = ListNode(s.pop()) p =rev for i in range(n-1): p.next = ListNode(s.pop()) p = p.next return rev Locating the midpoint of Linked ListSorting Linked List","categories":[],"tags":[{"name":"Data Structer","slug":"Data-Structer","permalink":"http://yoursite.com/tags/Data-Structer/"}]},{"title":"Attentions when using Linked List","slug":"Attentions when using Linked List","date":"2018-05-12T05:02:46.000Z","updated":"2018-05-12T14:11:05.378Z","comments":true,"path":"2018/05/12/Attentions when using Linked List/","link":"","permalink":"http://yoursite.com/2018/05/12/Attentions when using Linked List/","excerpt":"","text":"Here I want to list the mistakes I made when using linked list Empty linked listSometimes an empty list is given to check if the program takes into account the special circumstances of the input. Process of boundary nodes12345678910prevnode = headp = head.nextwhile p: nextnode = p.next p.next = prevnode prevnode = p p = nextnodenewll = prevnode a short and seemed effect code to reverse a given linked list strated with head, but when we want to count the length of ‘newll’ the program will never stop. Why? Because we forget to process the first node of the original linkedlist: head. head.next still exist and it points to second node in the original linkedlist so this is a infinite linked list where nodes switch back and forth between the first and second nodes. Linked list breakWhenever we want to change node.next, remember to record the ‘name’ of next node by assinging another variable, otherwise the linked list will break.","categories":[],"tags":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://yoursite.com/tags/Data-Structure/"}]},{"title":"Iterator and list resolution in Python (Part A)","slug":"Iterator and list resolution in Python (Part A)","date":"2018-05-07T14:37:31.000Z","updated":"2018-05-12T05:07:15.083Z","comments":true,"path":"2018/05/07/Iterator and list resolution in Python (Part A)/","link":"","permalink":"http://yoursite.com/2018/05/07/Iterator and list resolution in Python (Part A)/","excerpt":"","text":"Introduction to IteratorTo understand how iterator works in Python, let’s take some for loops for example: 123456789&gt;&gt;&gt; for x in [1,2,3,4]: print(x, end = ' ')1 2 3 4 &gt;&gt;&gt; for x in (1,2,3,4): print(x, end = ' ')1 2 3 4 &gt;&gt;&gt; for x in 'spam': print(x, end = ' ')s p a m In fact, the source ([1,2,3,4], (1,2,3,4) and ‘spam’ there) of the loop variable(x) in for loop can be more general than these three types, it can be any Iterable objects. The concept of “Iterable objects” is kind of novel in Python but very common in programming. There is a generalized definition: Any object that is actually saved as a list or that can produce one result at a time in an iterative tool environment is an iterable object. In the example above three sources are all iterable objects because they can provide a result in every loop. The iterative tools we mentioned in the definition is corresponsive to iterable objects which scan objects from left to right. These iterative tools include for loops, list comprehensions, in membership tests, and map built-in functions One famous application of iterable object is file operation. We know that there is a method named readline() for file object which will return one line of text in the file opened once called: 1234567&gt;&gt;&gt; f = open('helloworld.py')&gt;&gt;&gt; f.readline()'import sys\\n'&gt;&gt;&gt; f.readline()\"print('hello world!')\"&gt;&gt;&gt; f.readline()'' Now we can use another method of file object named next which can achieve the same result: it will return next line of text once called. 12345678910&gt;&gt;&gt; f = open('helloworld.py')&gt;&gt;&gt; f.__next__()'import sys\\n'&gt;&gt;&gt; f.__next__()\"print('hello world!')\"&gt;&gt;&gt; f.__next__()Traceback (most recent call last): File \"&lt;pyshell#32&gt;\", line 1, in &lt;module&gt; f.__next__()StopIteration There are two features worth attention. First is that every time next() method called, the next result of the object will be returned, so we can judge whether an object is an iterator by checking it. Second is a difference between file.next() and file.readline() that when it reaches the end of a series of results, it will trigger an exception named StopIteration. We can catch this exception to determine when to leave when using iterative tools we mentioned above. When we know that there is a method named next() in file object, we can make sure that file object is a iterable object so we can use iterative tools to simplify our codes: 1234&gt;&gt;&gt; for line in open('helloworld.py'): print(line, end='')import sysprint('hello world!') In fact, all iterative tools will call the next()method of the iterable objects every loop to get the next result in the object. At this point we may have the following questions: The list is the first iterable object we know and be most familiar with, what happens when we try to call list.next()? 123456&gt;&gt;&gt; a=[1,2,3,4]&gt;&gt;&gt; a.__next__()Traceback (most recent call last): File \"&lt;pyshell#47&gt;\", line 1, in &lt;module&gt; a.__next__()AttributeError: 'list' object has no attribute '__next__' Oops! What’s wrong with list? To understand this error, we need to be clear about two terms: iterable object and iterator. The biggest difference between them is that iterator has next() method but an iterable object does not. To make it direct, a list is an iterable object but not an iterator so it does not have a next() method, while a file is both an iterable object and an iterator. In fact, we can use a built-in function called iter() to change an iterable object into a iterator. We can use this example to show the difference between list and file: 123456789101112131415&gt;&gt;&gt; a=[1,2,3,4]&gt;&gt;&gt; b=iter(a)&gt;&gt;&gt; b.__next__()1&gt;&gt;&gt; b.__next__()2&gt;&gt;&gt; b.__next__()3&gt;&gt;&gt; b.__next__()4&gt;&gt;&gt; b.__next__()Traceback (most recent call last): File \"&lt;pyshell#55&gt;\", line 1, in &lt;module&gt; b.__next__()StopIteration 1234567891011&gt;&gt;&gt; f=open('helloworld.py')&gt;&gt;&gt; c=iter(f)&gt;&gt;&gt; c.__next__()'import sys\\n'&gt;&gt;&gt; c.__next__()\"print('hello world!')\"&gt;&gt;&gt; c.__next__()Traceback (most recent call last): File \"&lt;pyshell#60&gt;\", line 1, in &lt;module&gt; c.__next__()StopIteration 1234567891011&gt;&gt;&gt; f=open('helloworld.py')&gt;&gt;&gt; f.__next__()'import sys\\n'&gt;&gt;&gt; f.__next__()\"print('hello world!')\"&gt;&gt;&gt; c=iter(f)&gt;&gt;&gt; c.__next__()#Attention here! next(c) returns the same result of next(f) Traceback (most recent call last): File \"&lt;pyshell#65&gt;\", line 1, in &lt;module&gt; c.__next__()StopIteration By now, we have a preliminary understanding of iterators. It is a good tool in programming if applied properly. In most common cases, we can use iterator together with for loop to take place of while loop to run faster. Because iterators run in Python at the speed of C language, while the while loop runs python bytecode through the python virtual machine. At any time, it should be faster if we replace the python code with the C code. There are two often used iterable object: dictionary and range() 1234567891011&gt;&gt;&gt; Dict = &#123;'a':1,'b':2,'c':3&#125;&gt;&gt;&gt; for i in Dict: print(i, Dict[i])a 1b 2c 3&gt;&gt;&gt; for i in range(2):print(i)01 Attention that we need to wrap an iterable object into a list call to see all the values at once 1234&gt;&gt;&gt; range(2)range(0, 2)&gt;&gt;&gt; list(range(2))[0, 1] Introduction to list resolutionList resolution derives from the concept of collections. It is a way to create a new list by running an expression on each item in the sequence, one at a time, from left to right. List resolutions are composed of square brackets (reminding us the fact that we are creating a list) and operational expressions and loop structures that use the same variable name. Let’s look at an example: 1234&gt;&gt;&gt; L = [1,2,3,4]&gt;&gt;&gt; L1 = [x+10 for x in L]&gt;&gt;&gt; L1[11, 12, 13, 14] In this example, the operational expression(x+10) and loop structure(for x in L) use the same variable(x). During execution, the python interpreter internally performs a list traversal, assigns each x in order to an element and collects the results of running the left expression for each element. The list of results we get is a list containing a new list of x+10 for each x from L. When we use list resolution together with iterators, it greatly simplifies our code. At any time we want to perform same operations on each element in a sequence, we can consider the usage of list resolution: 123&gt;&gt;&gt; lines = [line.rstrip() for line in open('helloworld.py')]&gt;&gt;&gt; lines['import sys', \"print('hello world!')\"] If we want to skip some element in a consequence, we can use an if judgement to filter the list resolution: 12&gt;&gt;&gt; [x for x in range(5) if x%2 ==0][0, 2, 4] When the for expression in resolution is nested, it equals to nested for loop when run: 12&gt;&gt;&gt; [x + y for x in [0,1,2] for y in [10,20,30]][10, 20, 30, 11, 21, 31, 12, 22, 32] Equals to: (Pay attention to the outer loop variable(x) and inner loop variable(y)) 123456&gt;&gt;&gt; res = []&gt;&gt;&gt; for x in [0,1,2]: for y in [10,20,30]: res.append(x+y)&gt;&gt;&gt; res[10, 20, 30, 11, 21, 31, 12, 22, 32] A typical usage is given below: 12&gt;&gt;&gt; [(x,y) for x in range(5) if x%2==0 for y in range(5) if y%2 ==1][(0, 1), (0, 3), (2, 1), (2, 3), (4, 1), (4, 3)] It is worth mentioning that list resolution allows us to perform matrix operations in Python more easily. A basic method to operate matrix is to use nested list: 1234567891011121314&gt;&gt;&gt; M = [[1,2,3], [4,5,6], [7,8,9]]&gt;&gt;&gt; N = [[2,2,2], [3,3,3], [4,4,4]]&gt;&gt;&gt; [row[1] for row in M][2, 5, 8]&gt;&gt;&gt; [M[i][i] for i in range(len(M))][1, 5, 9]&gt;&gt;&gt; [M[row][col] * N[row][col] for row in range(3) for col in range(3)][2, 4, 6, 12, 15, 18, 28, 32, 36]&gt;&gt;&gt; [[M[row][col] * N[row][col] for row in range(3) ]for col in range(3)][[2, 12, 28], [4, 15, 32], [6, 18, 36]] Attention to the difference here resulted from consequence of inner and outer loop","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-05-06T07:06:54.592Z","updated":"2018-05-06T07:06:54.593Z","comments":true,"path":"2018/05/06/hello-world/","link":"","permalink":"http://yoursite.com/2018/05/06/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}