{"meta":{"title":"Goodboy Bobby","subtitle":"The world sucks, but I gonna love it","description":"The world sucks, but I gonna love it","author":"Lipeng Zhu","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"Bit manipulations","slug":"Bit manipulations","date":"2018-06-17T07:48:52.000Z","updated":"2018-06-17T08:00:09.402Z","comments":true,"path":"2018/06/17/Bit manipulations/","link":"","permalink":"http://yoursite.com/2018/06/17/Bit manipulations/","excerpt":"","text":"Before saying anything else, let’s declare the legal stuff: I collected all these little helpful pieces of code on the internet. All links are listed in the Reference. In this passage, I want to collect some commonly used bit manupulations. 1. Bit manipulation basicsHere are the basics of boolean algebra:*0 OR 0 → 00 OR 1 → 11 OR 0 → 11 OR 1 → 1 0 AND 0 → 00 AND 1 → 01 AND 0 → 01 AND 1 → 1 0 XOR 0 → 00 XOR 1 → 11 XOR 0 → 11 XOR 1 → 0*Whenever a bit needs to be set independent of its former state (setBit), OR comes in handy: input OR 1 → 1input OR 0 → input That means, a mask which is 1 for all bits to be set and 0 for all other bits fulfills our purposes (line 3, line 4). For clearing a bit (clearBit), AND has to be chosen because: input AND 0 → 0input AND 1 → input This time, the mask must be 0 for all cleared bits and 1 for bits keeping their former state.Line 10 uses the bit-wise negation to flip all bits of the mask accordingly. Flipping a bit (flipBit) is the domain of XOR: input XOR 1 → opposite of inputinput XOR 0 → input That code looks almost identical to OR.","categories":[],"tags":[{"name":"C","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"Algorithms","slug":"Algorithms","permalink":"http://yoursite.com/tags/Algorithms/"}]},{"title":"Commonly used operations of Dict","slug":"Commonly used operations of Dict","date":"2018-06-02T15:05:07.000Z","updated":"2018-06-02T15:16:48.486Z","comments":true,"path":"2018/06/02/Commonly used operations of Dict/","link":"","permalink":"http://yoursite.com/2018/06/02/Commonly used operations of Dict/","excerpt":"","text":"Here I want to list some commonly used operations of dictionary in Python. Reversing [Key Value]It is not easy to reverse &lt;key, value&gt; when there are duplicated values: 1234&gt;&gt;&gt; c1 = &#123;'a':1,'b':2,'c':1&#125;&gt;&gt;&gt; c2 = dict([(v,k) for k,v in c1.items()])&gt;&gt;&gt; c2&#123;1: 'c', 2: 'b'&#125; The right way to hold all keys in new value list is as below:Sort Characters By Frequency-solution-using-Hash-Map.) 123456&gt;&gt;&gt; c2 = &#123;&#125;&gt;&gt;&gt; for k,v in c1.items(): c2.setdefault(v,[]).append(k)&gt;&gt;&gt; c2&#123;1: ['a', 'c'], 2: ['b']&#125;","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"Applications of Fast and Slow Pointers","slug":"Applications of Fast and Slow Pointers","date":"2018-05-27T17:08:12.000Z","updated":"2018-05-27T17:52:24.386Z","comments":true,"path":"2018/05/28/Applications of Fast and Slow Pointers/","link":"","permalink":"http://yoursite.com/2018/05/28/Applications of Fast and Slow Pointers/","excerpt":"","text":"There are many applications of fast and slow pointers where ‘fast’ and ‘slow’ describe the step length of the pointers move. Applications in Linked List1.Judging a circular Linked ListIf there is a circle in the list, it looks like a circle playground. Let the fast and slow pointers traverse from the head of the list, the fast pointer moves two nodes forward each time while the slow pointer moves one. If the fast pointer reaches NULL, the linked list ends with NULL, and there is no cirle. If the fast pointer catches up with the slow pointer, it is a circular linked list. Linked List Cycle12345678910111213141516def hasCycle(self, head): \"\"\" :type head: ListNode :rtype: bool \"\"\" try: slow = head fast = head.next while slow is not fast: slow = slow.next fast = fast.next.next return True except: return False 2.Finding the median in an ordered Linked ListThe fast pointer moves twice as fast as the slow pointer, so when the fast pointer reaches the end of the list, the slow pointer reaches the midpoint. We should also consider the odd and even number of linked list nodes. When the fast pointer moves to the end of the table after x setp, it indicates that the linked list has an odd number of nodes, and the node pointed by the slow pointer can be directly returned as the median. If the fast pointer is the penultimate node, indicating that the number of linked list nodes is even, we can return to the upper or lower median according to the given rules. 1234567891011121314def findMedian(self, head): \"\"\" :type head: ListNode :rtype: ListNode \"\"\" slow = head fast = head while fast and fast.next: slow = slow.next fast = fast.next.next return slow 3.Finding the last K nodeThe concept of ‘fast’ and ‘slow’ can not only represent the speed of the movement, but also can be used to show the order of movement. We can define two pointers: The fast pointer walks forward by k-1 steps firstly while the slow pointer keeps still. From the Kth step, the second pointer also starts from the head of the linked list. Since the distance between two pointers keeps k-1, when the fast pointer reaches the end node of the list, the second pointer points Kth node from the bottom of the list. 123456789101112131415161718def getLastKthNode(self, k, head): \"\"\" :type head: ListNode :type k: int :rtype: ListNode \"\"\" slow = head fast = head for i in range(k): fast = fast.next while fast: fast = fast.next slow = slow.next return slow 4. Finding the entry node to the circular Linked ListApplications in ArrayGiven an array nums, write a function to move all 0s to the end of it while maintaining the relative order of the non-zero elements. We can use the slow pointer to indicate the first 0 waiting for swap while the fast pointer to indicate the current element Move Zeroes12345678910def moveZeroes(self, nums): \"\"\" :type nums: List[int] :rtype: void Do not return anything, modify nums in-place instead. \"\"\" zero = 0 for i in range(len(nums)): if not nums[i] == 0 and zero &lt;= i: nums[i], nums[zero] = nums[zero], nums[i] zero += 1","categories":[],"tags":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://yoursite.com/tags/Algorithms/"}]},{"title":"Little tricks of Array in Python","slug":"Little tricks of Array in Python","date":"2018-05-20T11:25:23.000Z","updated":"2018-05-20T12:42:27.330Z","comments":true,"path":"2018/05/20/Little tricks of Array in Python/","link":"","permalink":"http://yoursite.com/2018/05/20/Little tricks of Array in Python/","excerpt":"","text":"Important hints Could you do it without extra space and in O(n) runtime? “No extra space” means that we should modify the array itself to record some information and O(n) runtime usually means that we should have only one loop. For example, we can use the positive and negative values of elements in the array to record their occurences: Given an array of integers, 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once. Find all the elements that appear twice in this array. 123456789101112def findDuplicates(self, nums): \"\"\" :type nums: List[int] :rtype: List[int] \"\"\" res = [] for x in nums: if nums[abs(x)-1] &lt; 0: res.append(abs(x)) else: nums[abs(x)-1] *= -1 return res In the same way, if we need a solution with O(log n), we need to figure out binary tree or recursion: Given a sorted array consisting of only integers where every element appears twice except for one element which appears once. Find this single element that appears only once. 1234567891011121314151617181920212223242526272829def singleNonDuplicate(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" def recursion(nums): if len(nums) == 3: if nums[0] == nums[1]: return nums[2] else: return nums[0] flag = math.ceil(len(nums)/2) a = nums[:flag] b = nums[flag:] if flag%2 : if a[-1] == b[0]: return recursion([a[-1]] + b) else: return recursion(a) else: if a[-1] == b[0]: return recursion(a[:-1]) else: return recursion(b) return recursion(nums) Given an array of integers, 1 ≤ a[i] ≤ n (n = size of array). “1 ≤ a[i] ≤ n” guides us to use value of a[i] as the index of elements like a[a[i]] just like the first example above.","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"},{"name":"Data Structure","slug":"Data-Structure","permalink":"http://yoursite.com/tags/Data-Structure/"}]},{"title":"Leetcode Wrong Answers","slug":"Leetcode Wrong Answers","date":"2018-05-16T13:56:07.000Z","updated":"2018-05-16T14:00:44.623Z","comments":true,"path":"2018/05/16/Leetcode Wrong Answers/","link":"","permalink":"http://yoursite.com/2018/05/16/Leetcode Wrong Answers/","excerpt":"","text":"Linked List328. Odd Even Linked List 83. Remove Duplicates from Sorted List 445. Add Two Numbers II","categories":[],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://yoursite.com/tags/Leetcode/"}]},{"title":"Commonly used operations of Linked List","slug":"Commonly used operations of Linked List","date":"2018-05-12T14:09:08.000Z","updated":"2018-05-15T09:49:19.346Z","comments":true,"path":"2018/05/12/Commonly used operations of Linked List/","link":"","permalink":"http://yoursite.com/2018/05/12/Commonly used operations of Linked List/","excerpt":"","text":"Here I want to list some commonly used operations of linked list. Reversing Linked ListThere are two typical ways to reverse the linkedlist: iteratively or recursively. 1234class ListNode(object): def __init__(self, x): self.val = x self.next = None 12345678910111213141516#Iterativelydef reverseList(self, head): \"\"\" :type head: ListNode :rtype: ListNode \"\"\" prevnode = None p = head while p: nextnode = p.next p.next = prevnode prevnode = p p = nextnode return prevnode 123456789101112#Recursivelydef reverseList(self, head, prev = None): \"\"\" :type head: ListNode :rtype: ListNode \"\"\" if not head: return prev curr = head.next head.next = prev return self.reverseList(curr, head) It can also achieve the same effect using stack. 12345678910111213141516171819202122class StackUnderflow(ValueError): passclass SStack(): def __init__(self): self._elems = [] def is_empty(self): return self._elems == [] def top(self): if self._elems == []: raise StackUnderflow(\"in SStack.top()\") return self._elems[-1] def push(self, elem): self._elems.append(elem) def pop(self): if self._elems == []: raise StackUnderflow(\"in SStack.pop()\") return self._elems.pop() 12345678910111213141516171819202122#Stackdef reverseList(self, head): \"\"\" :type head: ListNode :rtype: ListNode \"\"\" s = SStack() n = 0 while head: s.push(head.val) head = head.next n += 1 rev = ListNode(s.pop()) p =rev for i in range(n-1): p.next = ListNode(s.pop()) p = p.next return rev Locating the Midpoint of Linked ListSorting Linked List &amp; Deleting and Inserting NodesInsertion Sort: Use p to indicate the insertion position, cur.next to indicate the target node, and cur to indicate the biggest node (also the last node) in the sorted linked list partition before the target node. When deleting and inserting nodes we need to know the nodes before the one to be removed and the one before the position to insert 1234567891011121314151617def insertionSortList(self, head): p = dummy = ListNode(0) cur = dummy.next = head while cur and cur.next: val = cur.next.val if cur.val&lt;val: #a quick check see if the new value is already the largest cur = cur.next #not necessary but key to improve effeciency continue if p.next.val&gt;val: p = dummy while p.next.val &lt;val: #find the position to insert p = p.next temp = cur.next #delete 'cur.next' and insert into list after 'p' cur.next = temp.next #we need a extra node 'temp' to record temp.next = p.next p.next = temp return dummy.next Merging two Linked ListsWe must follow certain rules when merging two lists and we assume here to merge two sorted lists in ascending order 12345678910111213# iterativelydef mergeTwoLists1(self, l1, l2): dummy = cur = ListNode(0) while l1 and l2: if l1.val &lt; l2.val: cur.next = l1 l1 = l1.next else: cur.next = l2 l2 = l2.next cur = cur.next cur.next = l1 or l2 #Tends to be faster using if judgement return dummy.next 12345678910# recursively def mergeTwoLists2(self, l1, l2): if not l1 or not l2: return l1 or l2 if l1.val &lt; l2.val: l1.next = self.mergeTwoLists(l1.next, l2) return l1 else: l2.next = self.mergeTwoLists(l1, l2.next) return l2","categories":[],"tags":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://yoursite.com/tags/Data-Structure/"}]},{"title":"Attentions when using Linked List","slug":"Attentions when using Linked List","date":"2018-05-12T05:02:46.000Z","updated":"2018-05-15T03:55:47.954Z","comments":true,"path":"2018/05/12/Attentions when using Linked List/","link":"","permalink":"http://yoursite.com/2018/05/12/Attentions when using Linked List/","excerpt":"","text":"Here I want to list the mistakes I made when using linked list Empty linked listSometimes an empty list is given to check if the program takes into account the special circumstances of the input. Take care especially when we use ‘head.next’ at the very beginning. We can use the following code to filter those naughty input: 12if head is None or head.next is None: return head 15/15/2018 Wrong Again! Process of boundary nodes12345678910prevnode = headp = head.nextwhile p: nextnode = p.next p.next = prevnode prevnode = p p = nextnodenewll = prevnode a short and seemed effect code to reverse a given linked list strated with head, but when we want to count the length of ‘newll’ the program will never stop. Why? Because we forget to process the first node of the original linkedlist: head. head.next still exist and it points to second node in the original linkedlist so this is a infinite linked list where nodes switch back and forth between the first and second nodes. There is another kind of error-prone case: Sometime the head node may be removed from the linked list, using ‘head’ node to index a linked list in this case is error prone. Example Linked list breakWhenever we want to change node.next, remember to record the ‘name’ of next node by assinging another variable, otherwise the linked list will break.","categories":[],"tags":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://yoursite.com/tags/Data-Structure/"}]},{"title":"Iterator and list resolution in Python (Part A)","slug":"Iterator and list resolution in Python (Part A)","date":"2018-05-07T14:37:31.000Z","updated":"2018-05-12T05:07:15.083Z","comments":true,"path":"2018/05/07/Iterator and list resolution in Python (Part A)/","link":"","permalink":"http://yoursite.com/2018/05/07/Iterator and list resolution in Python (Part A)/","excerpt":"","text":"Introduction to IteratorTo understand how iterator works in Python, let’s take some for loops for example: 123456789&gt;&gt;&gt; for x in [1,2,3,4]: print(x, end = ' ')1 2 3 4 &gt;&gt;&gt; for x in (1,2,3,4): print(x, end = ' ')1 2 3 4 &gt;&gt;&gt; for x in 'spam': print(x, end = ' ')s p a m In fact, the source ([1,2,3,4], (1,2,3,4) and ‘spam’ there) of the loop variable(x) in for loop can be more general than these three types, it can be any Iterable objects. The concept of “Iterable objects” is kind of novel in Python but very common in programming. There is a generalized definition: Any object that is actually saved as a list or that can produce one result at a time in an iterative tool environment is an iterable object. In the example above three sources are all iterable objects because they can provide a result in every loop. The iterative tools we mentioned in the definition is corresponsive to iterable objects which scan objects from left to right. These iterative tools include for loops, list comprehensions, in membership tests, and map built-in functions One famous application of iterable object is file operation. We know that there is a method named readline() for file object which will return one line of text in the file opened once called: 1234567&gt;&gt;&gt; f = open('helloworld.py')&gt;&gt;&gt; f.readline()'import sys\\n'&gt;&gt;&gt; f.readline()\"print('hello world!')\"&gt;&gt;&gt; f.readline()'' Now we can use another method of file object named next which can achieve the same result: it will return next line of text once called. 12345678910&gt;&gt;&gt; f = open('helloworld.py')&gt;&gt;&gt; f.__next__()'import sys\\n'&gt;&gt;&gt; f.__next__()\"print('hello world!')\"&gt;&gt;&gt; f.__next__()Traceback (most recent call last): File \"&lt;pyshell#32&gt;\", line 1, in &lt;module&gt; f.__next__()StopIteration There are two features worth attention. First is that every time next() method called, the next result of the object will be returned, so we can judge whether an object is an iterator by checking it. Second is a difference between file.next() and file.readline() that when it reaches the end of a series of results, it will trigger an exception named StopIteration. We can catch this exception to determine when to leave when using iterative tools we mentioned above. When we know that there is a method named next() in file object, we can make sure that file object is a iterable object so we can use iterative tools to simplify our codes: 1234&gt;&gt;&gt; for line in open('helloworld.py'): print(line, end='')import sysprint('hello world!') In fact, all iterative tools will call the next()method of the iterable objects every loop to get the next result in the object. At this point we may have the following questions: The list is the first iterable object we know and be most familiar with, what happens when we try to call list.next()? 123456&gt;&gt;&gt; a=[1,2,3,4]&gt;&gt;&gt; a.__next__()Traceback (most recent call last): File \"&lt;pyshell#47&gt;\", line 1, in &lt;module&gt; a.__next__()AttributeError: 'list' object has no attribute '__next__' Oops! What’s wrong with list? To understand this error, we need to be clear about two terms: iterable object and iterator. The biggest difference between them is that iterator has next() method but an iterable object does not. To make it direct, a list is an iterable object but not an iterator so it does not have a next() method, while a file is both an iterable object and an iterator. In fact, we can use a built-in function called iter() to change an iterable object into a iterator. We can use this example to show the difference between list and file: 123456789101112131415&gt;&gt;&gt; a=[1,2,3,4]&gt;&gt;&gt; b=iter(a)&gt;&gt;&gt; b.__next__()1&gt;&gt;&gt; b.__next__()2&gt;&gt;&gt; b.__next__()3&gt;&gt;&gt; b.__next__()4&gt;&gt;&gt; b.__next__()Traceback (most recent call last): File \"&lt;pyshell#55&gt;\", line 1, in &lt;module&gt; b.__next__()StopIteration 1234567891011&gt;&gt;&gt; f=open('helloworld.py')&gt;&gt;&gt; c=iter(f)&gt;&gt;&gt; c.__next__()'import sys\\n'&gt;&gt;&gt; c.__next__()\"print('hello world!')\"&gt;&gt;&gt; c.__next__()Traceback (most recent call last): File \"&lt;pyshell#60&gt;\", line 1, in &lt;module&gt; c.__next__()StopIteration 1234567891011&gt;&gt;&gt; f=open('helloworld.py')&gt;&gt;&gt; f.__next__()'import sys\\n'&gt;&gt;&gt; f.__next__()\"print('hello world!')\"&gt;&gt;&gt; c=iter(f)&gt;&gt;&gt; c.__next__()#Attention here! next(c) returns the same result of next(f) Traceback (most recent call last): File \"&lt;pyshell#65&gt;\", line 1, in &lt;module&gt; c.__next__()StopIteration By now, we have a preliminary understanding of iterators. It is a good tool in programming if applied properly. In most common cases, we can use iterator together with for loop to take place of while loop to run faster. Because iterators run in Python at the speed of C language, while the while loop runs python bytecode through the python virtual machine. At any time, it should be faster if we replace the python code with the C code. There are two often used iterable object: dictionary and range() 1234567891011&gt;&gt;&gt; Dict = &#123;'a':1,'b':2,'c':3&#125;&gt;&gt;&gt; for i in Dict: print(i, Dict[i])a 1b 2c 3&gt;&gt;&gt; for i in range(2):print(i)01 Attention that we need to wrap an iterable object into a list call to see all the values at once 1234&gt;&gt;&gt; range(2)range(0, 2)&gt;&gt;&gt; list(range(2))[0, 1] Introduction to list resolutionList resolution derives from the concept of collections. It is a way to create a new list by running an expression on each item in the sequence, one at a time, from left to right. List resolutions are composed of square brackets (reminding us the fact that we are creating a list) and operational expressions and loop structures that use the same variable name. Let’s look at an example: 1234&gt;&gt;&gt; L = [1,2,3,4]&gt;&gt;&gt; L1 = [x+10 for x in L]&gt;&gt;&gt; L1[11, 12, 13, 14] In this example, the operational expression(x+10) and loop structure(for x in L) use the same variable(x). During execution, the python interpreter internally performs a list traversal, assigns each x in order to an element and collects the results of running the left expression for each element. The list of results we get is a list containing a new list of x+10 for each x from L. When we use list resolution together with iterators, it greatly simplifies our code. At any time we want to perform same operations on each element in a sequence, we can consider the usage of list resolution: 123&gt;&gt;&gt; lines = [line.rstrip() for line in open('helloworld.py')]&gt;&gt;&gt; lines['import sys', \"print('hello world!')\"] If we want to skip some element in a consequence, we can use an if judgement to filter the list resolution: 12&gt;&gt;&gt; [x for x in range(5) if x%2 ==0][0, 2, 4] When the for expression in resolution is nested, it equals to nested for loop when run: 12&gt;&gt;&gt; [x + y for x in [0,1,2] for y in [10,20,30]][10, 20, 30, 11, 21, 31, 12, 22, 32] Equals to: (Pay attention to the outer loop variable(x) and inner loop variable(y)) 123456&gt;&gt;&gt; res = []&gt;&gt;&gt; for x in [0,1,2]: for y in [10,20,30]: res.append(x+y)&gt;&gt;&gt; res[10, 20, 30, 11, 21, 31, 12, 22, 32] A typical usage is given below: 12&gt;&gt;&gt; [(x,y) for x in range(5) if x%2==0 for y in range(5) if y%2 ==1][(0, 1), (0, 3), (2, 1), (2, 3), (4, 1), (4, 3)] It is worth mentioning that list resolution allows us to perform matrix operations in Python more easily. A basic method to operate matrix is to use nested list: 1234567891011121314&gt;&gt;&gt; M = [[1,2,3], [4,5,6], [7,8,9]]&gt;&gt;&gt; N = [[2,2,2], [3,3,3], [4,4,4]]&gt;&gt;&gt; [row[1] for row in M][2, 5, 8]&gt;&gt;&gt; [M[i][i] for i in range(len(M))][1, 5, 9]&gt;&gt;&gt; [M[row][col] * N[row][col] for row in range(3) for col in range(3)][2, 4, 6, 12, 15, 18, 28, 32, 36]&gt;&gt;&gt; [[M[row][col] * N[row][col] for row in range(3) ]for col in range(3)][[2, 12, 28], [4, 15, 32], [6, 18, 36]] Attention to the difference here resulted from consequence of inner and outer loop","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-05-06T07:06:54.592Z","updated":"2018-05-06T07:06:54.593Z","comments":true,"path":"2018/05/06/hello-world/","link":"","permalink":"http://yoursite.com/2018/05/06/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}