{"meta":{"title":"The Street Where Wind Settles","subtitle":"The world sucks, but I gonna love it","description":"The world sucks, but I gonna love it","author":"Lipeng Zhu","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"Iterator and list resolution in Python (Part A)","slug":"Iterator and list resolution in Python (Part A)","date":"2018-05-07T14:37:31.000Z","updated":"2018-05-10T07:26:01.119Z","comments":true,"path":"2018/05/07/Iterator and list resolution in Python (Part A)/","link":"","permalink":"http://yoursite.com/2018/05/07/Iterator and list resolution in Python (Part A)/","excerpt":"","text":"Iterator and list resolution in Python (Part A)Introduction to IteratorTo understand how iterator works in Python, let us take some for loop for example: ` bash for x in [1,2,3,4]: print(x, end = ‘ ‘) 1 2 3 4 for x in (1,2,3,4): print(x, end = ‘ ‘) 1 2 3 4 for x in ‘spam’: print(x, end = ‘ ‘) s p a m` bash In fact, the source ([1,2,3,4], (1,2,3,4) and ‘spam’ there) of the loop variable(x) in for loop can be more general than these three types, it can be any Iterable objects. The concept of “Iterable objects” is kind of novel in Python but very common in programming. There is a generalized definition: Any object that is actually saved as a list or that can produce one result at a time in an iterative tool environment is an iterable object. In the example above three sources are all iterable objects because they can provide a result in every loop. The iterative tools we mentioned in the definition is corresponsive to iterable objects which scan objects from left to right. These iterative tools include for loops, list comprehensions, in membership tests, and map built-in functions One famous application of iterable object is file operation. We know that there is a method named readline() for file object which will return one line of text in the file opened once called: ` bash f = open(‘helloworld.py’)f.readline()‘import sys\\n’f.readline()“print(‘hello world!’)”f.readline()‘’` bash Now we can use another method of file object named next which can achieve the same result: it will return next line of text once called. ` bash f = open(‘helloworld.py’)f.next()‘import sys\\n’f.next()“print(‘hello world!’)”f.next()Traceback (most recent call last): File “&lt;pyshell#32&gt;”, line 1, in f.next()StopIteration` bash There are two features worth attention. First is that every time next() method called, the next result of the object will be returned, so we can judge whether an object is an iterator by checking it. Second is a difference between file.next() and file.readline() that when it reaches the end of a series of results, it will trigger an exception named StopIteration. We can catch this exception to determine when to leave when using iterative tools we mentioned above. When we know that there is a method named next() in file object, we can make sure that file object is a iterable object so we can use iterative tools to simplify our codes: ` bash for line in open(‘helloworld.py’): print(line, end=’’)` bash import sysprint(‘hello world!’) In fact, all iterative tools will call the next()method of the iterable objects every loop to get the next result in the object. At this point we may have the following questions: The list is the first iterable object we know and be most familiar with, what happens when we try to call list.next()? ` bash a=[1,2,3,4]a.next()Traceback (most recent call last): File “&lt;pyshell#47&gt;”, line 1, in a.next()AttributeError: ‘list’ object has no attribute ‘next‘` bash Oops! What’s wrong with list? To understand this error, we need to be clear about two terms: iterable object and iterator. The biggest difference between them is that iterator has next() method but an iterable object does not. To make it direct, a list is an iterable object but not an iterator so it does not have a next() method, while a file is both an iterable object and an iterator. In fact, we can use a built-in function called iter() to change an iterable object into a iterator. We can use this example to show the difference between list and file: ` bash a=[1,2,3,4]b=iter(a)b.next()1b.next()2b.next()3b.next()4b.next()Traceback (most recent call last): File “&lt;pyshell#55&gt;”, line 1, in b.next()StopIteration` bash ` bash f=open(‘helloworld.py’)c=iter(f)c.next()‘import sys\\n’c.next()“print(‘hello world!’)”c.next()Traceback (most recent call last): File “&lt;pyshell#60&gt;”, line 1, in c.next()StopIteration` bash ` bash f=open(‘helloworld.py’)f.next()‘import sys\\n’f.next()“print(‘hello world!’)”c=iter(f)c.next() #Attention here! next(c) returns the same result of next(f)Traceback (most recent call last): File “&lt;pyshell#65&gt;”, line 1, in c.next()StopIteration` bash By now, we have a preliminary understanding of iterators. It is a good tool in programming if applied properly. In most common cases, we can use iterator together with for loop to take place of while loop to run faster. Because iterators run in Python at the speed of C language, while the while loop runs python bytecode through the python virtual machine. At any time, it should be faster if we replace the python code with the C code. There are two often used iterable object: dictionary and range() ` bash Dict = {‘a’:1,’b’:2,’c’:3}for i in Dict: print(i, Dict[i]) a 1b 2c 3 for i in range(2):print(i) 01` bash Attention that we need to wrap an iterable object into a list call to see all the values at once ` bash range(2)range(0, 2)list(range(2))[0, 1]` bash Introduction to list resolutionList resolution derives from the concept of collections. It is a way to create a new list by running an expression on each item in the sequence, one at a time, from left to right. List resolutions are composed of square brackets (reminding us the fact that we are creating a list) and operational expressions and loop structures that use the same variable name. Let’s look at an example: ` bash L = [1,2,3,4]L1 = [x+10 for x in L]L1[11, 12, 13, 14]` bash In this example, the operational expression(x+10) and loop structure(for x in L) use the same variable(x). During execution, the python interpreter internally performs a list traversal, assigns each x in order to an element and collects the results of running the left expression for each element. The list of results we get is a list containing a new list of x+10 for each x from L. When we use list resolution together with iterators, it greatly simplifies our code. At any time we want to perform same operations on each element in a sequence, we can consider the usage of list resolution: ` bash lines = [line.rstrip() for line in open(‘helloworld.py’)]lines[‘import sys’, “print(‘hello world!’)”]` bash If we want to skip some element in a consequence, we can use an if judgement to filter the list resolution: ` bash [x for x in range(5) if x%2 ==0][0, 2, 4]` bash When the for expression in resolution is nested, it equals to nested for loop when run: ` bash [x + y for x in [0,1,2] for y in [10,20,30]][10, 20, 30, 11, 21, 31, 12, 22, 32]` bash Equals to: (Pay attention to the outer loop variable(x) and inner loop variable(y)) ` bash res = []for x in [0,1,2]: for y in [10,20,30]: res.append(x+y)res[10, 20, 30, 11, 21, 31, 12, 22, 32]` bash A typical usage is given below: ` bash [(x,y) for x in range(5) if x%2==0 for y in range(5) if y%2 ==1][(0, 1), (0, 3), (2, 1), (2, 3), (4, 1), (4, 3)]` bash It is worth mentioning that list resolution allows us to perform matrix operations in Python more easily. A basic method to operate matrix is to use nested list: ` bash M = [[1,2,3], [4,5,6], [7,8,9]]N = [[2,2,2], [3,3,3], [4,4,4]][row[1] for row in M][2, 5, 8][M[i][i] for i in range(len(M))][1, 5, 9][M[row][col] N[row][col] for row in range(3) for col in range(3)][2, 4, 6, 12, 15, 18, 28, 32, 36][[M[row][col] N[row][col] for row in range(3) ]for col in range(3)][[2, 12, 28], [4, 15, 32], [6, 18, 36]]` bash Attention to the difference here resulted from consequence of inner and outer loop","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-05-06T07:06:54.592Z","updated":"2018-05-06T07:06:54.593Z","comments":true,"path":"2018/05/06/hello-world/","link":"","permalink":"http://yoursite.com/2018/05/06/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}